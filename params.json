{
  "name": "SIBAP prototyping",
  "tagline": "ScrIpt-Based Aspect-oriented Prototyping framework",
  "body": "\r\n**This implementation corresponds to a research work. It is ready to be downloaded and integrated into Qt/C++ projects. It uses Lua as the prototyping language**\r\n\r\nFirst of all, watch this ;-)\r\nhttps://www.youtube.com/watch?v=H9-wh-08BSg\r\n\r\nThis framework proposes to treat prototyping as a separate aspect of the agile development process.\r\nPrototype designs are completely reused and iteratively refined towards the\r\nfinal GUI design. In parallel, final functionality is implemented and\r\nsmoothly integrated into the prototype replacing prototyped behaviors.\r\n\r\nThe design and implementation of a framework supporting this approach is\r\npresented. It uses separate files to define prototyped behaviors, which are written\r\nusing general-purpose scripting languages and executed by an\r\ninterpreter. The GUI and the final functionality run natively.\r\nNative and interpreted functionality coexist and run in parallel within the\r\napplication.\r\n\r\nAs a result, developers and UX designers work in parallel, separately, but\r\ncollaborating on the same software artifact. This encourages communication\r\nduring development. Scripting languages allow also to change the prototype on-the-fly in order\r\nto incorporate suggestions from different stakeholders in real time. This\r\nallows to gather feedback more effectively by implementing participatory\r\ndesign techniques.\r\n\r\n## Running example\r\n\r\nWhile the SIBAP framework is included in `sibapfw` folder, an example including this\r\nframework is included in `test` folder. \r\n\r\nThis example can be easily opened, compiled and run with \r\nQtCreator (https://www.qt.io/ide/). \r\nBehavior files are included in `behavior` folder. \r\nAn execution log can be found at `/tmp/sibap_behavior.log`.\r\n\r\n\r\n\r\n## Framework integration\r\n\r\nThe integration process is divided into two stages: configuration and deployment.\r\n\r\nStage 1: Configuration. The process is easily configured using a BehaviorConfiguration\r\nobject. This object encapsulates all configuration data needed during execution (e.g., the di-rectory of behavior files or refreshing time) It can be instantiated from a configuration file:\r\n\r\n    int main(int argc, char *argv[])\r\n    {\r\n        QApplication qapp(argc, argv);\r\n        MainWindow w;\r\n        w.show();\r\n\r\n        ///\r\n        /// behavior layer configuration\r\n\r\n        // Alternative 1\r\n        //BehaviorConfiguration bconf(\"../layer.config\");\r\n\r\n        // Alternative 2\r\n        //BehaviorConfiguration bconf;\r\n        //bconf.loadConfigFile(\"layer.config\");\r\n\r\n        // Alternative 3\r\n        BehaviorConfiguration bconf;\r\n        bconf.updateFileTime(10)\r\n             .logFormat(\"[%tm] %wi Event:%en :: State: %cs :: Assertion: %ar :: Function Called: %fc :: Result: %fr\")\r\n             .addLogOutputFile(\"/tmp/sibap_behavior.log\")\r\n             .addScriptPath(\"./test/behavior/\");\r\n\r\n        // You can also configure if the log info goes to the screen.\r\n        // Available parameters are on,off\r\n        // StandardOutput=on\r\n        // StandardError=off\r\n    ...\r\n\r\nStage 2: Deployment. Once the configuration object is created, it is used to create and configure a new BehaviorLayer. The BehaviorLayer object encapsulates the whole prototyping framework. Once created, the\r\ninit() method is called to deploy and start the behavior service:\r\n\r\n\r\n    ...\r\n        ///\r\n        /// behavior layer deployment\r\n\r\n        QtLua_BehaviorLayer blayer(&bconf);\r\n        blayer.init();\r\n\r\n        ///\r\n\r\n        return qapp.exec();\r\n    }\r\n\r\n## Framework functions\r\n\r\n### Main function template\r\n\r\n    state_stateID__event__widget()  // Executed when event is performed on widget \r\n                                    // being in state stateID. state stateID is optional.\r\n\r\n### Initialization functions\r\n\r\n    init__widget()                  // Initialization of widget\r\n    state_stateID__widget()         // Initialization of widget when stateID is enabled\r\n    \r\nExample:\r\n\r\n    function init__di_ampliLevel()\r\n        __log(\"Initializing dials\")\r\n        MainWindow.di_ampliLevel:setValue(50)\r\n        MainWindow.di_signalEcho:setValue(50)\r\n        MainWindow.di_nrLevel:setValue(50)\r\n        MainWindow.di_volumeLevel:setValue(50)\r\n    end\r\n\r\n### State functions\r\n\r\n    state__stateID()                // Does transition to state stateID. (State functions\r\n                                    // are automatically defined by SIBAP).\r\n\r\n### Assert functions\r\n\r\n    assert__widget()                // Assertion for a widget must be satisfied for its\r\n                                    // behavior functions to be executed.\r\n                                    \r\nExample:\r\n\r\n    function assert__hs_balanceLevel()\r\n       __log(\"Asserting balance\")\r\n       balance=MainWindow.hs_balanceLevel:value()\r\n       return balance >= 0 and balance <= 99\r\n    end\r\n\r\n### Logging functions\r\n\r\n    log__widget()                   // Executed when widget is interacted\r\n    event__log()                    // Executed when event is performed\r\n    __log(content)                  // Adds content to log streams\r\n    __flog(fileName,content)        // Adds content to the file fileName\r\n\r\n\r\n### Supporting functions\r\n\r\nAll the expressiveness of the scripting language\r\n(Lua in this case) and its interpreter can be used to define the behavior\r\nof a GUI. Variables, data structures, supporting functions, etc. can be\r\nused in the behavior functions to compute additional values and build\r\nhigh-quality prototypes.\r\n\r\nExamples:\r\n\r\n    function calculatePower()\r\n       power=buffer_size * 0.5 + sample_rate * 0.5\r\n       ...\r\n    end\r\n\r\n    function setChannelsValue()\r\n       aux=power*2\r\n       MainWindow.pb_left:setValue(power * ((100-balance)/100)*2)\r\n       ...\r\n    end\r\n\r\n    function updateValues()\r\n       calculatePower()\r\n       setChannelsValue()\r\n    end\r\n\r\n## Framework events\r\n\r\nAll the following scene events (i.e., those application events related to user \r\ninteraction) are supported by SIBAP, thus can be used to define behavior functions:\r\n\r\n- `click`\r\n- `doubleclick`\r\n- `wheel`\r\n- `focusin`\r\n- `focusout`\r\n- `mouseoverenter`\r\n- `mouseoverleave`\r\n- `mouseovermove`\r\n- `keypress`\r\n- `keyrelease`\r\n- `show`\r\n- `hide`\r\n- `repaint`\r\n\r\nExamples:\r\n\r\n    function click__di_ampliLevel()\r\n       __log(\"Changing amplification\")\r\n       amplification=MainWindow.di_ampliLevel:value()\r\n       MainWindow.lc_ampliLevel:display(amplification)\r\n       updateValues() -- supporting functions can be used as well\r\n    end\r\n\r\n    function wheel__hs_balanceLevel()\r\n       __log(\"Changing balance\")\r\n       balance=MainWindow.hs_balanceLevel:value()\r\n       updateValues()\r\n    end\r\n\r\n\r\n## Prototype initialization\r\n\r\nDesigners start creating a file, say initialization.lua, to define how the\r\nvalues in the prototype GUI are initialized. This file is included in the directory\r\nbehavior/MainWindow/ to indicate that this behavior file corresponds to the dialog with\r\nname MainWindow. init * functions are used to initialize the prototype (see above).\r\n\r\n    function init__widget_name()\r\n      MainWindow.a_widget:setValue(0)\r\n      MainWindow.another_widget:setValue(0)\r\n    end\r\n\r\n## Defining prototyped behavors\r\n\r\nIn order to define new prototyped behavior, a new file, say somebehavior.lua, is created\r\nin the behavior/MainWindow/ folder. The following code is used to handle the click event\r\nperformed on the widget1 widget:\r\n\r\n    value, result = 0\r\n    \r\n    function click__widget1()\r\n       value = MainWindow.widget2:value()\r\n       calculateSomething()\r\n    end\r\n    \r\n    function calculateSomething()\r\n       result = ...\r\n    end\r\n\r\nSupporting functions can be used along with behavior functions.\r\n\r\n\r\n## Integrating native functionality\r\n\r\nAt some point during the development, prototyped behaviors are replaced with the corresponding native functionality. Native functionality is implemented, as usual, using C++ methods and functions. Once the native functionality is integrated into the implementation of the application (i.e., the *.h and *.cpp files) the corresponding prototyped behaviors need to be removed from the script files. \r\n\r\nAfter recompiling and relaunching the application (needed to make native functionality work) the application will respond now with native functionality when the corresponding widget is interacted.\r\n\r\n\r\n\r\n\r\nGo to http://www.catedrasaes.org/html/projects/sibap/sibap.html for further project description.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}